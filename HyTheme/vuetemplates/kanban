<div id="kanban">
    <kanban-component></kanban-component>

    <script>
    {% raw %}
    vueapp.component("KanbanComponent", {
        data: () => ({
            dialog: false,
            draggedTask: null,
            dragOverColumn: null,
            snackbar: false,
            snackbarColor: "success",
            snackbarMessage: "",
            isEdit: false,
            projects: [], // Will be loaded from GraphQL
            users: [], // Will be loaded from GraphQL
            columns: [
                { name: "To Do", key: "todo" },
                { name: "In Progress", key: "progress" },
                { name: "Done", key: "done" }
            ],
            tasks: [], // Will be loaded from GraphQL
            form: {
                id: null,
                contentItemId: null,
                title: "",
                projectId: null,
                assignee: null, // userId
                start: "",
                finish: "",
                estStart: "",
                estFinish: "",
                status: "todo",
                modifiedUtc: '',
                publishedUtc: '',
                createdUtc: '',
                owner: '',
                render: '',
                author: ''
            }
        }),

        methods: {
                                                            async fetchUsers() {
                                                                const query = `{
                                                                  users {
                                                                    userId
                                                                    normalizedUserName
                                                                    normalizedEmail
                                                                  }
                                                                }`;
                                                                try {
                                                                    const response = await fetch('/api/graphql', {
                                                                        method: 'POST',
                                                                        headers: {
                                                                            'Content-Type': 'application/json'
                                                                        },
                                                                        body: JSON.stringify({ query })
                                                                    });
                                                                    const result = await response.json();
                                                                    if (result.data && result.data.users) {
                                                                        this.users = result.data.users.map(u => ({
                                                                            id: u.userId,
                                                                            name: u.normalizedUserName,
                                                                            email: u.normalizedEmail
                                                                        }));
                                                                    } else {
                                                                        this.users = [];
                                                                    }
                                                                } catch (e) {
                                                                    this.showToast('Failed to load users: ' + e.message, 'error');
                                                                }
                                                            },
                                                async fetchProjects() {
                                                    const query = `{
                                                      project(first: 50, skip: 0) {
                                                        contentItemId
                                                        projectTitle
                                                        projectStartDate
                                                        projectFinishDate
                                                      }
                                                    }`;
                                                    try {
                                                        const response = await fetch('/api/graphql', {
                                                            method: 'POST',
                                                            headers: {
                                                                'Content-Type': 'application/json'
                                                            },
                                                            body: JSON.stringify({ query })
                                                        });
                                                        const result = await response.json();
                                                        if (result.data && result.data.project) {
                                                            this.projects = result.data.project.map(p => ({
                                                                id: p.contentItemId,
                                                                name: p.projectTitle,
                                                                start: p.projectStartDate,
                                                                finish: p.projectFinishDate
                                                            }));
                                                        } else {
                                                            this.projects = [];
                                                        }
                                                    } catch (e) {
                                                        this.showToast('Failed to load projects: ' + e.message, 'error');
                                                    }
                                                },
            async fetchTasks() {
                const query = `
                {
                  task(first: 50, skip: 0) {
                    contentItemVersionId
                    contentItemId
                    displayText
                    modifiedUtc
                    publishedUtc
                    createdUtc
                    owner
                    render
                    baselineStartDate
                    baselineFinishDate
                    finishDate
                    startDate
                    taskStatus
                    assignee {
                      userIds
                      users {
                        userName
                        email
                        userId
                      }
                    }
                    author
                    relatedProject {
                      contentItemIds
                    }
                  }
                }
                `;
                try {
                    const response = await fetch('/api/graphql', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ query })
                    });
                    const result = await response.json();
                    if (result.data && result.data.task) {
                        // Map GraphQL data to Kanban task model
                        this.tasks = result.data.task.map(t => ({
                            id: t.contentItemVersionId,
                            contentItemId: t.contentItemId,
                            title: t.displayText,
                            projectId: t.relatedProject?.contentItemIds?.[0] || null,
                            assignee: t.assignee?.users?.[0]?.userId || t.author || null,
                            start: t.startDate || '',
                            finish: t.finishDate || '',
                            estStart: t.baselineStartDate || '',
                            estFinish: t.baselineFinishDate || '',
                            status: t.taskStatus ? t.taskStatus.toLowerCase() : 'todo',
                            modifiedUtc: t.modifiedUtc || '',
                            publishedUtc: t.publishedUtc || '',
                            createdUtc: t.createdUtc || '',
                            owner: t.owner || '',
                            render: t.render || '',
                            author: t.author || ''
                        }));
                    } else {
                        this.tasks = [];
                    }
                } catch (e) {
                    this.showToast('Failed to load tasks: ' + e.message, 'error');
                }
            },
            onDragStart(task, event) {
                    this.draggedTask = task;

                    // Add dragging class
                    event.target.classList.add("dragging");
                },

                onDragEnd(event) {
                    // Remove dragging class
                    event.target.classList.remove("dragging");
                    this.draggedTask = null;
                    this.dragOverColumn = null;
                },

                onDragOver(columnKey) {
                    this.dragOverColumn = columnKey;
                },

                onDragLeave(columnKey) {
                    if (this.dragOverColumn === columnKey) {
                        this.dragOverColumn = null;
                    }
                },

                onDrop(columnKey) {
                    if (!this.draggedTask) return;

                    this.draggedTask.status = columnKey;
                    this.saveDragTask(this.draggedTask);

                    this.dragOverColumn = null;
                    this.draggedTask = null;
                },

            openNew() {
                this.isEdit = false;
                this.resetForm();
                this.dialog = true;
            },

            openEdit(task) {
                this.isEdit = true;
                // Map all task properties to form
                this.form = {
                    id: task.id,
                    contentItemId: task.contentItemId,
                    title: task.title,
                    projectId:task.projectId,// this.projects.find(p => p.id === task.projectId),
                    assignee: this.users.find(u => u.id === task.assignee),
                    start: task.start,
                    finish: task.finish,
                    estStart: task.estStart,
                    estFinish: task.estFinish,
                    status: task.status,
                    modifiedUtc: task.modifiedUtc,
                    publishedUtc: task.publishedUtc,
                    createdUtc: task.createdUtc,
                    owner: task.owner,
                    render: task.render,
                    author: task.author
                };
                this.dialog = true;
            },

            resetForm() {
                this.form = {
                    id: null,
                    contentItemId: null,
                    title: "",
                    projectId: null,
                    assignee: "",
                    start: "",
                    finish: "",
                    estStart: "",
                    estFinish: "",
                    status: "todo"
                };
            },
            saveDragTask(task) {
                // Simulated permission check
                const hasAccess = true; // change to false to test "access denied"
                if (!hasAccess) {
                    this.showToast("Access Denied", "error");
                    return;
                }

                // Prepare payload based on form
                const payload = {
                    ContentType: "Task",
                    ContentItemId: task.contentItemId || undefined,
                    Latest: true,
                    Published: true,
                    Task: {
                        TaskStatus: {
                            Text: task.status
                        }
                    }
                };

                // Determine method and URL
                let method = "POST";
                let url = "/api/Hycontent/";
                // For update, you may need to use PUT and pass the id/contentItemId

                // Fetch API call
                fetch(url, {
                    method: method,
                    headers: {
                        'Content-Type': 'application/json',
                        'RequestVerificationToken': document.querySelector("input[name='__RequestVerificationToken']")?.value || ""
                    },
                    body: JSON.stringify(payload)
                })
                .then(async response => {
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(errorText);
                    }
                    return response.json();
                })
                .catch(error => {
                    this.showToast("Error updating content: " + error.message, "error");
                });

                this.showToast("Task updated successfully", "success");
            },

            saveTask() {
                // Simulated permission check
                const hasAccess = true; // change to false to test "access denied"
                if (!hasAccess) {
                    this.showToast("Access Denied", "error");
                    return;
                }

                // Prepare payload based on form
                const payload = {
                    ContentType: "Task",
                    ContentItemId: this.form.contentItemId || undefined,
                    DisplayText: this.form.title,
                    Latest: true,
                    Published: true,
                    Owner: this.form.owner || "4mcsr8e425d90v7zqgvz0ps6nd", // Example owner
                    Author: this.form.author || "admin",
                    Task: {
                        text: {
                            Text: this.form.title + " text"
                        },
                        RelatedProject: {
                            ContentItemIds: this.form.projectId ? [this.form.projectId] : []
                        },
                        Assignee: {
                            UserIds: this.form.assignee ? [this.form.assignee.id] : []
                        },
                        TaskStatus: {
                            Text: this.form.status
                        },
                        BaselineFinishDate: {
                            Value: this.form.estFinish
                        },
                        BaselineStartDate: {
                            Value: this.form.estStart
                        },
                        StartDate: {
                            Value: this.form.start
                        },
                        FinishDate: {
                            Value: this.form.finish
                        }
                    },
                    TitlePart: {
                        Title: this.form.title
                    }
                };

                // Determine method and URL
                let method = this.isEdit ? "POST" : "POST";
                let url = "/api/Hycontent/";
                // For update, you may need to use PUT and pass the id/contentItemId

                // Fetch API call
                fetch(url, {
                    method: method,
                    headers: {
                        'Content-Type': 'application/json',
                        'RequestVerificationToken': document.querySelector("input[name='__RequestVerificationToken']")?.value || ""
                    },
                    body: JSON.stringify(payload)
                })
                .then(async response => {
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(errorText);
                    }
                    return response.json();
                })
                .then(data => {
                    if (this.isEdit) {
                        const index = this.tasks.findIndex(t => t.id === this.form.id);
                        if (index !== -1) {
                            this.tasks[index] = { ...this.form };
                        }
                    } else {
                        this.form.id = data.id || Date.now();
                        this.tasks.push({ ...this.form });
                    }
                    this.persist();
                    this.dialog = false;
                    this.showToast("Task saved successfully", "success");
                })
                .catch(error => {
                    this.showToast("Error updating content: " + error.message, "error");
                });
            },

            persist() {
                // No-op or optionally update localStorage if you want offline support
            },

            showToast(msg, color) {
                this.snackbarMessage = msg;
                this.snackbarColor = color;
                this.snackbar = true;
            }
        },

        async mounted() {
            await this.fetchProjects();
            await this.fetchUsers();
            await this.fetchTasks();
        },

        template: `
        <div class="pa-4">

            <v-btn color="primary" class="mb-4" @click="openNew">
                New Task
            </v-btn>

            <v-row>
               <v-col
    v-for="col in columns"
    :key="col.key"
    @dragover.prevent="onDragOver(col.key)"
    @dragleave="onDragLeave(col.key)"
    @drop="onDrop(col.key)"
>
    <div :class="{'drop-zone': col.key === dragOverColumn}">
        <h3>{{ col.name }}</h3>

                    <v-card
                        v-for="task in tasks.filter(t => t.status === col.key)"
                        :key="task.id"
                        class="mb-3 pa-3"
                       draggable="true"
                        @dragstart="onDragStart(task, $event)"
                        @dragend="onDragEnd"
                        @click="openEdit(task)"
                    >
                         <div class="d-flex align-center justify-space-between">
                        <strong>{{ task.title }}</strong>

                        <!-- Drag handle -->
                        <v-icon class="drag-handle" size="20">mdi-drag</v-icon>
                    </div>
                        <small>Project: {{ projects.find(p => p.id === task.projectId)?.name }}</small><br>
                        <small>StartDate: {{ task.start}}</small>
                    </v-card>
                    </div>
                </v-col>
            </v-row>

            <!-- Task Modal -->
            <v-dialog v-model="dialog" max-width="600px">
                <v-card>
                    <v-card-title>
                        {{ isEdit ? "Edit Task" : "New Task" }}
                    </v-card-title>

                    <v-card-text>
                        <v-text-field label="Title" v-model="form.title"></v-text-field>

                        <v-select
                            label="Related Project"
                            :items="projects"
                            item-title="name"
                            item-value="id"
                            v-model="form.projectId"
                        ></v-select>

                        <v-select
                            label="Assignee"
                            :items="users"
                            item-title="name"
                            item-value="id"
                            v-model="form.assignee"
                            return-object="false"
                        ></v-select>

                        <v-row>
                            <v-col>
                                <v-text-field type="date" label="Start" v-model="form.start"></v-text-field>
                            </v-col>
                            <v-col>
                                <v-text-field type="date" label="Finish" v-model="form.finish"></v-text-field>
                            </v-col>
                        </v-row>

                        <v-row>
                            <v-col>
                                <v-text-field type="date" label="Estimated Start" v-model="form.estStart"></v-text-field>
                            </v-col>
                            <v-col>
                                <v-text-field type="date" label="Estimated Finish" v-model="form.estFinish"></v-text-field>
                            </v-col>
                        </v-row>

                        <v-select
                            label="Status"
                            :items="columns"
                            item-title="name"
                            item-value="key"
                            v-model="form.status"
                        ></v-select>
                    </v-card-text>

                    <v-card-actions>
                        <v-btn text @click="dialog = false">Cancel</v-btn>
                        <v-btn color="primary" @click="saveTask">Save</v-btn>
                    </v-card-actions>
                </v-card>
            </v-dialog>

            <!-- Snackbar -->
            <v-snackbar v-model="snackbar" :color="snackbarColor" timeout="2000">
                {{ snackbarMessage }}
            </v-snackbar>

        </div>
        `
    });
    {% endraw %}
    </script>
</div>
